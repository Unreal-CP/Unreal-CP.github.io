---
title: UI
description: åœ¨è¿™ä¸ªå…¨é¢çš„æ¦‚è¿°ä¸­ï¼Œå¼€å§‹å­¦ä¹ Chirpyçš„åŸºç¡€çŸ¥è¯†ã€‚æ‚¨å°†å­¦ä¹ å¦‚ä½•å®‰è£…ã€é…ç½®å’Œä½¿ç”¨æ‚¨çš„ç¬¬ä¸€ä¸ªåŸºäºChirpyçš„ç½‘ç«™ï¼Œä»¥åŠå°†å…¶éƒ¨ç½²åˆ°webæœåŠ¡å™¨ã€‚
author: cotes
date: 2025-10-21 20:55:00 +0800
categories: [Lyra,UI]
tags: [ue,Lyra,ui]
pin: true
---

UIæ¡†æ¶
====
# é…ç½®å…³äºUIçš„iniæ–‡ä»¶
## DefaultGame.ini
```ini
[/Script/LyraGame.LyraUIManagerSubsystem]
DefaultUIPolicyClass=/Game/UI/B_LyraUIPolicy.B_LyraUIPolicy_C

[/Script/LyraGame.LyraUIMessaging]
ConfirmationDialogClass=/Game/UI/Foundation/Dialogs/W_ConfirmationDefault.W_ConfirmationDefault_C
ErrorDialogClass=/Game/UI/Foundation/Dialogs/W_ConfirmationError.W_ConfirmationError_C

[/Script/CommonLoadingScreen.CommonLoadingScreenSettings]
LoadingScreenWidget=/Game/UI/Foundation/LoadingScreen/W_LoadingScreen_Host.W_LoadingScreen_Host_C
ForceTickLoadingScreenEvenInEditor=False

[/Script/CommonInput.CommonInputSettings]
InputData=/Game/UI/B_CommonInputData.B_CommonInputData_C
bEnableInputMethodThrashingProtection=True
InputMethodThrashingLimit=30
InputMethodThrashingWindowInSeconds=3.000000
InputMethodThrashingCooldownInSeconds=1.000000
bAllowOutOfFocusDeviceInput=True

[/Script/CommonUI.CommonUISettings]
bAutoLoadData=True
DefaultImageResourceObject=None
DefaultThrobberMaterial=/Game/UI/Foundation/Materials/M_UI_Throbber_Base.M_UI_Throbber_Base
DefaultRichTextDataClass=/Game/UI/Foundation/RichTextData/CommonUIRichTextData.CommonUIRichTextData_C
+PlatformTraits=(TagName="Platform.Trait.SupportsWindowedMode")
+PlatformTraits=(TagName="Platform.Trait.CanExitApplication")
+PlatformTraits=(TagName="Platform.Trait.SupportsChangingAudioOutputDevice")
+PlatformTraits=(TagName="Platform.Trait.SupportsBackgroundAudio")
+PlatformTraits=(TagName="Platform.Trait.Input.SupportsMouseAndKeyboard")
+PlatformTraits=(TagName="Platform.Trait.Input.HardwareCursor")
+PlatformTraits=(TagName="")
+PlatformTraits=(TagName="Platform.Trait.NeedsBrightnessAdjustment")
+PlatformTraits=(TagName="Platform.Trait.ReplaySupport")
+PlatformTraits=(TagName="Platform.Trait.SupportsLatencyStats")
+PlatformTraits=(TagName="Platform.Trait.SupportsLatencyMarkers")
CommonButtonAcceptKeyHandling=Ignore

[CheatScript.DebugUI]
+Cmd=Log LogSlate VeryVerbose
+Cmd=Log LogUMG VeryVerbose
+Cmd=Log LogCommonUI VeryVerbose
+Cmd=Log LogCommonInput VeryVerbose
+Cmd=Log LogUIActionRouter VeryVerbose
+Cmd=SlateDebugger.Start
```


## DefaultEngine.ini
```ini
[DistillSettings]
+FilesToAlwaysDistill=UI/*

[/Script/Engine.Engine]
GameViewportClientClassName=/Script/LyraGame.LyraGameViewportClient
LocalPlayerClassName=/Script/LyraGame.LyraLocalPlayer

[/Script/Engine.UserInterfaceSettings]
RenderFocusRule=Never
HardwareCursors=()
SoftwareCursors=((Default, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(TextEditBeam, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(ResizeLeftRight, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(ResizeUpDown, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(ResizeSouthEast, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(ResizeSouthWest, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(CardinalCross, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(Crosshairs, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(Hand, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(GrabHand, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(GrabHandClosed, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(SlashedCircle, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"),(EyeDropper, "/Game/UI/Foundation/SoftwareCursors/W_ArrowCursor.W_ArrowCursor_C"))
ApplicationScale=1.000000
UIScaleRule=ScaleToFit
CustomScalingRuleClass=None
UIScaleCurve=(EditorCurveData=(Keys=((Time=480.000000,Value=0.444000),(Time=720.000000,Value=0.666000),(Time=1080.000000,Value=1.000000),(Time=8640.000000,Value=8.000000)),DefaultValue=340282346638528859811704183484516925440.000000,PreInfinityExtrap=RCCE_Constant,PostInfinityExtrap=RCCE_Constant),ExternalCurve=None)
bAllowHighDPIInGameMode=False
DesignScreenSize=(X=1920,Y=1080)
bLoadWidgetsOnDedicatedServer=True

[/Script/Engine.CollisionProfile]
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")

[ConsoleVariables]
gpad.DefaultLeftStickInnerDeadZone=0.24
gpad.DefaultRightStickInnerDeadZone=0.27

[EnumRemap]
TEXTUREGROUP_Project01.DisplayName=UI With MIPs
```


# è¦†å†™UIå­ç³»ç»Ÿ
**éœ€è¦ä½¿ç”¨Lyraé¡¹ç›®çš„æ’ä»¶è¿›è¡Œè¦†å†™**
## GameUIManagerSubsystem
```cpp
/**
 * This manager is intended to be replaced by whatever your game needs to
 * actually create, so this class is abstract to prevent it from being created.
 *
 * è¿™ä¸ªç®¡ç†å™¨æ—¨åœ¨æ ¹æ®æ‚¨çš„æ¸¸æˆå®é™…éœ€æ±‚è¿›è¡Œæ›¿æ¢ï¼Œå› æ­¤è¿™ä¸ªç±»æ˜¯æŠ½è±¡ç±»ï¼Œä»¥é˜²æ­¢å…¶è¢«åˆ›å»ºã€‚
 * 
 * If you just need the basic functionality you will start by sublcassing this
 * subsystem in your own game.
 *
 * å¦‚æœæ‚¨åªéœ€è¦åŸºæœ¬åŠŸèƒ½ï¼Œé‚£ä¹ˆæ‚¨åªéœ€åœ¨è‡ªå·±çš„æ¸¸æˆä¸­ç»§æ‰¿æ­¤å­ç³»ç»Ÿå³å¯ã€‚
 * 
 */
UCLASS(MinimalAPI, Abstract, config = Game)
class UGameUIManagerSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()
	
public:
	UGameUIManagerSubsystem() { }

	// åˆ›å»ºç­–ç•¥
	UE_API virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	// å›æ”¶ç­–ç•¥
	UE_API virtual void Deinitialize() override;
	// å¦‚æœå¼€å‘è€…æ²¡æœ‰è‡ªå®šä¹‰æ‰éœ€è¦åˆ›å»ºè¯¥å­ç³»ç»Ÿ
	UE_API virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
	// è·å–å½“å‰ç­–ç•¥
	const UGameUIPolicy* GetCurrentUIPolicy() const { return CurrentPolicy; }
	// è·å–å½“å‰ç­–ç•¥
	UGameUIPolicy* GetCurrentUIPolicy() { return CurrentPolicy; }
	// è½¬å‘
	UE_API virtual void NotifyPlayerAdded(UCommonLocalPlayer* LocalPlayer);
	// è½¬å‘
	UE_API virtual void NotifyPlayerRemoved(UCommonLocalPlayer* LocalPlayer);
	// è½¬å‘
	UE_API virtual void NotifyPlayerDestroyed(UCommonLocalPlayer* LocalPlayer);
protected:
	// åˆ‡æ¢ç­–ç•¥
	UE_API void SwitchToPolicy(UGameUIPolicy* InPolicy);
private:
	// æŒæœ‰
	UPROPERTY(Transient)
	TObjectPtr<UGameUIPolicy> CurrentPolicy = nullptr;
	// é…ç½®
	UPROPERTY(config, EditAnywhere)
	TSoftClassPtr<UGameUIPolicy> DefaultUIPolicyClass;
};

#undef UE_API
```


## LyraUIManagerSubsystemï¼ˆUIç®¡ç†å­ç³»ç»Ÿï¼‰
### LyraUIManagerSubsystem.h
```cpp
UCLASS()
class ULyraUIManagerSubsystem : public UGameUIManagerSubsystem
{
	GENERATED_BODY()

public:

	ULyraUIManagerSubsystem();

	// ç»‘å®šTick
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	// ç§»é™¤Tick
	virtual void Deinitialize() override;

private:
	// Tick
	bool Tick(float DeltaTime);
	// æ›´æ”¹UIå¸ƒå±€çš„å¯å®ç°
	void SyncRootLayoutVisibilityToShowHUD();
	
	FTSTicker::FDelegateHandle TickHandle;
};
```


### LyraUIManagerSubsystem.cpp
```cpp
void ULyraUIManagerSubsystem::SyncRootLayoutVisibilityToShowHUD()
{
	// Get the current UI policy to determine layout rules
	// è·å–å½“å‰UIç­–ç•¥æ¥ç¡®å®šå¸ƒå±€è§„åˆ™
	if (const UGameUIPolicy* Policy = GetCurrentUIPolicy())
	{
		// Check all local players' HUD visibility states
		// æ£€æŸ¥æ‰€æœ‰æœ¬åœ°ç©å®¶çš„HUDå¯è§æ€§çŠ¶æ€
		for (const ULocalPlayer* LocalPlayer : GetGameInstance()->GetLocalPlayers())
		{
			bool bShouldShowUI = true;

			// Check if the player controller's HUD is set to show
			// æ£€æŸ¥ç©å®¶æ§åˆ¶å™¨çš„HUDæ˜¯å¦è®¾ç½®ä¸ºæ˜¾ç¤º
			if (const APlayerController* PC = LocalPlayer->GetPlayerController(GetWorld()))
			{
				const AHUD* HUD = PC->GetHUD();

				// Hide UI if HUD is explicitly set to not show
				// å¦‚æœHUDæ˜ç¡®è®¾ç½®ä¸ºä¸æ˜¾ç¤ºï¼Œåˆ™éšè—UI
				if (HUD && !HUD->bShowHUD)
				{
					bShouldShowUI = false;
				}
			}

			// Apply visibility state to the root layout
			// å°†å¯è§æ€§çŠ¶æ€åº”ç”¨åˆ°æ ¹å¸ƒå±€
			if (UPrimaryGameLayout* RootLayout = Policy->GetRootLayout(CastChecked<UCommonLocalPlayer>(LocalPlayer)))
			{
				const ESlateVisibility DesiredVisibility = bShouldShowUI ? ESlateVisibility::SelfHitTestInvisible : ESlateVisibility::Collapsed;

				// Only update if visibility has changed to avoid unnecessary operations
				// ä»…åœ¨å¯è§æ€§å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„æ“ä½œ
				if (DesiredVisibility != RootLayout->GetVisibility())
				{
					RootLayout->SetVisibility(DesiredVisibility);
				}
			}
		}
	}
}
```


## LyraUIMessagingï¼ˆUIæ¶ˆæ¯å­ç³»ç»Ÿï¼‰
### LyraUIMessaging.h
```cpp
 // UI Messaging subsystem for handling game dialogs and user notifications
 // UIæ¶ˆæ¯å­ç³»ç»Ÿï¼Œç”¨äºå¤„ç†æ¸¸æˆå¯¹è¯æ¡†å’Œç”¨æˆ·é€šçŸ¥
UCLASS()
class ULyraUIMessaging : public UCommonMessagingSubsystem
{
	GENERATED_BODY()

public:
	ULyraUIMessaging() { }

	// Initialize the messaging subsystem and load dialog classes
	// åˆå§‹åŒ–æ¶ˆæ¯å­ç³»ç»Ÿå¹¶åŠ è½½å¯¹è¯æ¡†ç±»
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	// Show a confirmation dialog to the user
	// å‘ç”¨æˆ·æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
	virtual void ShowConfirmation(UCommonGameDialogDescriptor* DialogDescriptor, FCommonMessagingResultDelegate ResultCallback = FCommonMessagingResultDelegate()) override;

	// Show an error dialog to the user
	// å‘ç”¨æˆ·æ˜¾ç¤ºé”™è¯¯å¯¹è¯æ¡†
	virtual void ShowError(UCommonGameDialogDescriptor* DialogDescriptor, FCommonMessagingResultDelegate ResultCallback = FCommonMessagingResultDelegate()) override;

private:
	// Loaded confirmation dialog class for instantiation
	// å·²åŠ è½½çš„ç¡®è®¤å¯¹è¯æ¡†ç±»ï¼Œç”¨äºå®ä¾‹åŒ–
	UPROPERTY()
	TSubclassOf<UCommonGameDialog> ConfirmationDialogClassPtr;

	// Loaded error dialog class for instantiation
	// å·²åŠ è½½çš„é”™è¯¯å¯¹è¯æ¡†ç±»ï¼Œç”¨äºå®ä¾‹åŒ–
	UPROPERTY()
	TSubclassOf<UCommonGameDialog> ErrorDialogClassPtr;

	// Config reference to confirmation dialog class (soft reference for async loading)
	// é…ç½®ä¸­å¯¹ç¡®è®¤å¯¹è¯æ¡†ç±»çš„å¼•ç”¨ï¼ˆè½¯å¼•ç”¨ï¼Œç”¨äºå¼‚æ­¥åŠ è½½ï¼‰
	UPROPERTY(config)
	TSoftClassPtr<UCommonGameDialog> ConfirmationDialogClass;

	// Config reference to error dialog class (soft reference for async loading)
	// é…ç½®ä¸­å¯¹é”™è¯¯å¯¹è¯æ¡†ç±»çš„å¼•ç”¨ï¼ˆè½¯å¼•ç”¨ï¼Œç”¨äºå¼‚æ­¥åŠ è½½ï¼‰
	UPROPERTY(config)
	TSoftClassPtr<UCommonGameDialog> ErrorDialogClass;
};
```


### LyraUIMessaging.cpp
```cpp
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_UI_LAYER_MODAL, "UI.Layer.Modal");

void ULyraUIMessaging::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// Synchronously load the dialog classes from their soft references
	// ä»è½¯å¼•ç”¨åŒæ­¥åŠ è½½å¯¹è¯æ¡†ç±»
	ConfirmationDialogClassPtr = ConfirmationDialogClass.LoadSynchronous();
	ErrorDialogClassPtr = ErrorDialogClass.LoadSynchronous();
}

void ULyraUIMessaging::ShowConfirmation(UCommonGameDialogDescriptor* DialogDescriptor, FCommonMessagingResultDelegate ResultCallback)
{
	// Get the local player to find the root UI layout
	// è·å–æœ¬åœ°ç©å®¶ä»¥æŸ¥æ‰¾æ ¹UIå¸ƒå±€
	if (UCommonLocalPlayer* LocalPlayer = GetLocalPlayer<UCommonLocalPlayer>())
	{
		// Access the root layout where dialogs will be displayed
		// è®¿é—®å°†æ˜¾ç¤ºå¯¹è¯æ¡†çš„æ ¹å¸ƒå±€
		if (UPrimaryGameLayout* RootLayout = LocalPlayer->GetRootUILayout())
		{
			// Push the confirmation dialog to the modal layer with configuration
			// å°†ç¡®è®¤å¯¹è¯æ¡†æ¨é€åˆ°æ¨¡æ€å±‚å¹¶è¿›è¡Œé…ç½®
			RootLayout->PushWidgetToLayerStack<UCommonGameDialog>(TAG_UI_LAYER_MODAL, ConfirmationDialogClassPtr, [DialogDescriptor, ResultCallback](UCommonGameDialog& Dialog) {
				Dialog.SetupDialog(DialogDescriptor, ResultCallback);
			});
		}
	}
}

void ULyraUIMessaging::ShowError(UCommonGameDialogDescriptor* DialogDescriptor, FCommonMessagingResultDelegate ResultCallback)
{
	// Get the local player to find the root UI layout
	// è·å–æœ¬åœ°ç©å®¶ä»¥æŸ¥æ‰¾æ ¹UIå¸ƒå±€
	if (UCommonLocalPlayer* LocalPlayer = GetLocalPlayer<UCommonLocalPlayer>())
	{
		// Access the root layout where dialogs will be displayed
		// è®¿é—®å°†æ˜¾ç¤ºå¯¹è¯æ¡†çš„æ ¹å¸ƒå±€
		if (UPrimaryGameLayout* RootLayout = LocalPlayer->GetRootUILayout())
		{
			// Push the error dialog to the modal layer with configuration
			// å°†é”™è¯¯å¯¹è¯æ¡†æ¨é€åˆ°æ¨¡æ€å±‚å¹¶è¿›è¡Œé…ç½®
			RootLayout->PushWidgetToLayerStack<UCommonGameDialog>(TAG_UI_LAYER_MODAL, ErrorDialogClassPtr, [DialogDescriptor, ResultCallback](UCommonGameDialog& Dialog) {
				Dialog.SetupDialog(DialogDescriptor, ResultCallback);
			});
		}
	}
}
```


# CommonLoadingScreen_Plugins(é€šç”¨åŠ è½½ç•Œé¢)
## æµç¨‹ä»‹ç»
**1.å®šä¹‰ä¸€ä¸ªæ¥å£,è®©éœ€è¦ä½¿ç”¨åˆ°è¿™ä¸ªåŠŸèƒ½çš„å®ä¾‹ç»§æ‰¿è‡ªå®ƒ.
2.å®šä¹‰äº†ä¸€ä¸ªå¼€å‘è€…è®¾ç½®å¯ä»¥ç”¨äºåœ¨é¡¹ç›®ä¸­è®¾ç½®,å°†å…¶å˜é‡æš´éœ²åˆ°å‘½ä»¤è¡Œä¸­,å¯ä»¥å¿«æ·è°ƒè¯•
3.å®šä¹‰äº†ä¸€ä¸ªç®¡ç†ç±»,è´Ÿè´£ç›‘å¬æ‰€æœ‰æ¥å£å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸ,å¹¶é€šè¿‡è¯¥ç±»åˆ†å‘å…·ä½“çš„åŠŸèƒ½
4.æš´éœ²äº†è“å›¾é™æ€å‡½æ•°,å¼‚æ­¥è“å›¾èŠ‚ç‚¹ç­‰æ–¹å¼æä¾›ä¾¿æ·åœ°ä½¿ç”¨.**

## Interface_åŠ è½½è¿›ç¨‹æ¥å£
```cpp
/** Interface for things that might cause loading to happen which requires a loading screen to be displayed */
/** ç”¨äºè¡¨ç¤ºé‚£äº›å¯èƒ½ä¼šè§¦å‘åŠ è½½æ“ä½œï¼ˆä¸”è¯¥æ“ä½œéœ€è¦æ˜¾ç¤ºåŠ è½½ç•Œé¢ï¼‰çš„æ¥å£ */
UINTERFACE(MinimalAPI, BlueprintType)
class ULoadingProcessInterface : public UInterface
{
	GENERATED_BODY()
};

class ILoadingProcessInterface
{
	GENERATED_BODY()
public:
	// Checks to see if this object implements the interface, and if so asks whether or not we should
	// be currently showing a loading screen
	// æ£€æŸ¥è¯¥å¯¹è±¡æ˜¯å¦å®ç°äº†è¯¥æ¥å£ï¼Œå¦‚æœå®ç°äº†åˆ™è¯¢é—®æ˜¯å¦å½“å‰åº”æ˜¾ç¤ºåŠ è½½ç•Œé¢
	static UE_API bool ShouldShowLoadingScreen(UObject* TestObject, FString& OutReason);

	virtual bool ShouldShowLoadingScreen(FString& OutReason) const
	{
		return false;
	}
};
```


## LoadingScreenManagerï¼ˆç•Œé¢åŠ è½½ç®¡ç†ï¼‰
```cpp
/**
 * Handles showing/hiding the loading screen
 * æ§åˆ¶æ˜¾ç¤º/éšè—åŠ è½½ç•Œé¢
 */
UCLASS(MinimalAPI)
class ULoadingScreenManager : public UGameInstanceSubsystem, public FTickableGameObject
{
	GENERATED_BODY()

public:
	//~USubsystem interface
	// ç»‘å®šåœ°å›¾çš„å˜åŠ¨
	UE_API virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	// ç§»é™¤åŠ è½½å±å¹•çš„åŠŸèƒ½ 
	UE_API virtual void Deinitialize() override;
	// å®¢æˆ·ç«¯æ‰åˆ›å»º
	UE_API virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
	//~End of USubsystem interface

	//~FTickableObjectBase interface
	// æ¯å¸§æ£€æµ‹æ˜¯å¦è¦æ˜¾ç¤ºåŠ è½½å±å¹•
	UE_API virtual void Tick(float DeltaTime) override;
	// å†³å®šTickçš„å¼€å…³ç±»å‹
	UE_API virtual ETickableTickType GetTickableTickType() const override;
	// è¡¥å……æ˜¯å¦éœ€è¦æ˜¾ç¤ºåŠ è½½å±å¹•
	UE_API virtual bool IsTickable() const override;
	// ID
	UE_API virtual TStatId GetStatId() const override;
	// åº”ç”¨çš„ä¸–ç•Œ
	UE_API virtual UWorld* GetTickableGameObjectWorld() const override;
	//~End of FTickableObjectBase interface

	// æš´éœ²ç»™è“å›¾è¯¢é—®
	UFUNCTION(BlueprintCallable, Category=LoadingScreen)
	FString GetDebugReasonForShowingOrHidingLoadingScreen() const
	{
		return DebugReasonForShowingOrHidingLoadingScreen;
	}

	/** Returns True when the loading screen is currently being shown */
	/** å½“åŠ è½½ç•Œé¢æ­£åœ¨æ˜¾ç¤ºæ—¶è¿”å› True */
	bool GetLoadingScreenDisplayStatus() const
	{
		return bCurrentlyShowingLoadingScreen;
	}

	/** Called when the loading screen visibility changes  */
	/** å½“åŠ è½½ç•Œé¢çš„å¯è§æ€§å‘ç”Ÿå˜åŒ–æ—¶è°ƒç”¨ */
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnLoadingScreenVisibilityChangedDelegate, bool);
	FORCEINLINE FOnLoadingScreenVisibilityChangedDelegate& OnLoadingScreenVisibilityChangedDelegate() { return LoadingScreenVisibilityChanged; }

	// ç”±å…·ä½“çš„æ¥å£å®ä¾‹è¿›è¡Œç”Ÿå‘½å‘¨æœŸçš„æ³¨å†Œ
	UE_API void RegisterLoadingProcessor(TScriptInterface<ILoadingProcessInterface> Interface);
	UE_API void UnregisterLoadingProcessor(TScriptInterface<ILoadingProcessInterface> Interface);
	
private:
	// è§¦å‘æ›´æ–°
	UE_API void HandlePreLoadMap(const FWorldContext& WorldContext, const FString& MapName);
	// è§¦å‘æ›´æ–°
	UE_API void HandlePostLoadMap(UWorld* World);

	/** Determines if we should show or hide the loading screen. Called every frame. */
	/** ç”¨äºç¡®å®šæ˜¯å¦åº”æ˜¾ç¤ºæˆ–éšè—åŠ è½½ç•Œé¢ã€‚æ¯å¸§éƒ½ä¼šè°ƒç”¨æ­¤å‡½æ•°ã€‚*/
	UE_API void UpdateLoadingScreen();

	/** Returns true if we need to be showing the loading screen. */
	/** è‹¥éœ€è¦æ˜¾ç¤ºåŠ è½½ç•Œé¢ï¼Œåˆ™è¿”å› true ã€‚*/
	UE_API bool CheckForAnyNeedToShowLoadingScreen();

	/** Returns true if we want to be showing the loading screen (if we need to or are artificially forcing it on for other reasons). */
	/** è‹¥æˆ‘ä»¬å¸Œæœ›æ˜¾ç¤ºåŠ è½½ç•Œé¢ï¼Œåˆ™è¿”å› trueï¼ˆè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦æ˜¾ç¤ºè¯¥ç•Œé¢ï¼Œæˆ–è€…æ˜¯å› ä¸ºå…¶ä»–äººä¸ºåŸå› è€Œå¼ºåˆ¶æ˜¾ç¤ºï¼‰ã€‚*/
	UE_API bool ShouldShowLoadingScreen();

	/** Returns true if we are in the initial loading flow before this screen should be used */
	/** å¦‚æœæˆ‘ä»¬æ­£å¤„äºåˆå§‹åŠ è½½æµç¨‹ä¸­ï¼Œä¸”åœ¨æ­¤å±å¹•æŠ•å…¥ä½¿ç”¨ä¹‹å‰ï¼Œè¿”å› true */
	UE_API bool IsShowingInitialLoadingScreen() const;

	/** Shows the loading screen. Sets up the loading screen widget on the viewport */
	/** æ˜¾ç¤ºåŠ è½½ç•Œé¢ã€‚åœ¨è§†å£ä¸Šè®¾ç½®åŠ è½½ç•Œé¢ç»„ä»¶ */
	UE_API void ShowLoadingScreen();

	/** Hides the loading screen. The loading screen widget will be destroyed */
	/** éšè—åŠ è½½ç•Œé¢ã€‚åŠ è½½ç•Œé¢çš„ç»„ä»¶å°†ä¼šè¢«é”€æ¯ */
	UE_API void HideLoadingScreen();

	/** Removes the widget from the viewport */
	/** å°†è¯¥æ§ä»¶ä»è§†å£ä¸­ç§»é™¤ */
	UE_API void RemoveWidgetFromViewport();

	/** Prevents input from being used in-game while the loading screen is visible */
	/** åœ¨åŠ è½½ç•Œé¢æ˜¾ç¤ºæœŸé—´ï¼Œé˜²æ­¢è¾“å…¥å†…å®¹è¢«ç”¨äºæ¸¸æˆä¹‹ä¸­ */
	UE_API void StartBlockingInput();

	/** Resumes in-game input, if blocking */
	/** è‹¥å­˜åœ¨é˜»å¡æƒ…å†µï¼Œåˆ™æ¢å¤æ¸¸æˆä¸­çš„è¾“å…¥æ“ä½œ */
	UE_API void StopBlockingInput();

	// å˜æ›´ç”±äºåˆ‡æ¢åŠ è½½å±å¹•çš„æ€§èƒ½å½±å“
	UE_API void ChangePerformanceSettings(bool bEnabingLoadingScreen);

private:
	/** Delegate broadcast when the loading screen visibility changes */
	/** å½“åŠ è½½ç•Œé¢çš„å¯è§æ€§å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰§è¡Œå¹¿æ’­æ“ä½œ */
	FOnLoadingScreenVisibilityChangedDelegate LoadingScreenVisibilityChanged;

	/** A reference to the loading screen widget we are displaying (if any) */
	/** æŒ‡å‘æˆ‘ä»¬æ­£åœ¨æ˜¾ç¤ºçš„åŠ è½½å±å¹•ç»„ä»¶çš„å¼•ç”¨ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ */
	TSharedPtr<SWidget> LoadingScreenWidget;

	/** Input processor to eat all input while the loading screen is shown */
	/** ç”¨äºåœ¨åŠ è½½ç•Œé¢æ˜¾ç¤ºæœŸé—´æ¥æ”¶æ‰€æœ‰è¾“å…¥çš„è¾“å…¥å¤„ç†å™¨ */
	TSharedPtr<IInputProcessor> InputPreProcessor;

	/** External loading processors, components maybe actors that delay the loading. */
	/** å¤–éƒ¨åŠ è½½å¤„ç†å™¨ã€ç»„ä»¶å¯èƒ½åŒ…æ‹¬é‚£äº›ä¼šå»¶è¿ŸåŠ è½½è¿‡ç¨‹çš„æ‰§è¡Œè€…ã€‚*/
	TArray<TWeakInterfacePtr<ILoadingProcessInterface>> ExternalLoadingProcessors;

	/** The reason why the loading screen is up (or not) */
	/** åŠ è½½ç•Œé¢æ˜¯å¦æ˜¾ç¤ºï¼ˆæˆ–æœªæ˜¾ç¤ºï¼‰çš„åŸå›  */
	FString DebugReasonForShowingOrHidingLoadingScreen;

	/** The time when we started showing the loading screen */
	/** æˆ‘ä»¬å¼€å§‹æ˜¾ç¤ºåŠ è½½ç•Œé¢çš„æ—¶é—´ */
	double TimeLoadingScreenShown = 0.0;

	/** The time the loading screen most recently wanted to be dismissed (might still be up due to a min display duration requirement) **/
	/** åŠ è½½ç•Œé¢æœ€åä¸€æ¬¡æƒ³è¦è¢«å…³é—­çš„æ—¶é—´ï¼ˆç”±äºæœ€å°æ˜¾ç¤ºæ—¶é•¿è¦æ±‚ï¼Œè¯¥ç•Œé¢å¯èƒ½ä»å¤„äºæ˜¾ç¤ºçŠ¶æ€ï¼‰ **/
	double TimeLoadingScreenLastDismissed = -1.0;

	/** The time until the next log for why the loading screen is still up */
	/** ä¸‹ä¸€æ¬¡è®°å½•åŠ è½½å±å¹•ä»å¤„äºæ˜¾ç¤ºçŠ¶æ€çš„åŸå› æ‰€éœ€çš„æ—¶é—´ */
	double TimeUntilNextLogHeartbeatSeconds = 0.0;

	/** True when we are between PreLoadMap and PostLoadMap */
	/** å½“æˆ‘ä»¬å¤„äºâ€œé¢„åŠ è½½åœ°å›¾â€ä¸â€œååŠ è½½åœ°å›¾â€ä¹‹é—´æ—¶ä¸ºçœŸ */
	bool bCurrentlyInLoadMap = false;

	/** True when the loading screen is currently being shown */
	/** å½“åŠ è½½ç•Œé¢æ­£åœ¨æ˜¾ç¤ºæ—¶ä¸ºçœŸ */
	bool bCurrentlyShowingLoadingScreen = false;
};
```


### è¾“å…¥å±è”½
å¤´æ–‡ä»¶(.h)
``` cpp
	/** Prevents input from being used in-game while the loading screen is visible */
	/** åœ¨åŠ è½½ç•Œé¢æ˜¾ç¤ºæœŸé—´ï¼Œé˜²æ­¢è¾“å…¥å†…å®¹è¢«ç”¨äºæ¸¸æˆä¹‹ä¸­ */
	UE_API void StartBlockingInput();

	/** Resumes in-game input, if blocking */
	/** è‹¥å­˜åœ¨é˜»å¡æƒ…å†µï¼Œåˆ™æ¢å¤æ¸¸æˆä¸­çš„è¾“å…¥æ“ä½œ */
	UE_API void StopBlockingInput();
```
æºæ–‡ä»¶(.cpp)
``` cpp
// Input processor to throw in when loading screen is shown
// This will capture any inputs, so active menus under the loading screen will not interact
// åœ¨åŠ è½½ç•Œé¢æ˜¾ç¤ºæ—¶ä½¿ç”¨çš„è¾“å…¥å¤„ç†å™¨
// æ­¤å¤„ç†å™¨å°†æ•è·æ‰€æœ‰è¾“å…¥æ“ä½œï¼Œå› æ­¤åŠ è½½ç•Œé¢ä¸‹çš„æ´»åŠ¨èœå•å°†ä¸ä¼šä¸ä¹‹äº¤äº’
class FLoadingScreenInputPreProcessor : public IInputProcessor
{
public:
	FLoadingScreenInputPreProcessor() { }
	virtual ~FLoadingScreenInputPreProcessor() { }

	bool CanEatInput() const
	{
		return !GIsEditor;
	}

	//~IInputProcess interface
	virtual void Tick(const float DeltaTime, FSlateApplication& SlateApp, TSharedRef<ICursor> Cursor) override { }

	virtual bool HandleKeyDownEvent(FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent) override { return CanEatInput(); }
	virtual bool HandleKeyUpEvent(FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent) override { return CanEatInput(); }
	virtual bool HandleAnalogInputEvent(FSlateApplication& SlateApp, const FAnalogInputEvent& InAnalogInputEvent) override { return CanEatInput(); }
	virtual bool HandleMouseMoveEvent(FSlateApplication& SlateApp, const FPointerEvent& MouseEvent) override { return CanEatInput(); }
	virtual bool HandleMouseButtonDownEvent(FSlateApplication& SlateApp, const FPointerEvent& MouseEvent) override { return CanEatInput(); }
	virtual bool HandleMouseButtonUpEvent(FSlateApplication& SlateApp, const FPointerEvent& MouseEvent) override { return CanEatInput(); }
	virtual bool HandleMouseButtonDoubleClickEvent(FSlateApplication& SlateApp, const FPointerEvent& MouseEvent) override { return CanEatInput(); }
	virtual bool HandleMouseWheelOrGestureEvent(FSlateApplication& SlateApp, const FPointerEvent& InWheelEvent, const FPointerEvent* InGestureEvent) override { return CanEatInput(); }
	virtual bool HandleMotionDetectedEvent(FSlateApplication& SlateApp, const FMotionEvent& MotionEvent) override { return CanEatInput(); }
	//~End of IInputProcess interface
};
```


### æ›´æ–°åŠ è½½å±å¹•å¯è§†æ€§
``` cpp
void ULoadingScreenManager::UpdateLoadingScreen()
{
	bool bLogLoadingScreenStatus = LoadingScreenCVars::LogLoadingScreenReasonEveryFrame;

	if (ShouldShowLoadingScreen())
	{
		const UCommonLoadingScreenSettings* Settings = GetDefault<UCommonLoadingScreenSettings>();
		
		// If we don't make it to the specified checkpoint in the given time will trigger the hang detector so we can better determine where progress stalled.
		// å¦‚æœæˆ‘ä»¬æœªèƒ½åœ¨è§„å®šæ—¶é—´å†…åˆ°è¾¾æŒ‡å®šçš„æ£€æŸ¥ç‚¹ï¼Œå°±ä¼šè§¦å‘æŒ‚èµ·æ£€æµ‹æœºåˆ¶ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½æ›´æ¸…æ¥šåœ°äº†è§£è¿›åº¦åœæ»çš„å…·ä½“ä½ç½®ã€‚
 		FThreadHeartBeat::Get().MonitorCheckpointStart(GetFName(), Settings->LoadingScreenHeartbeatHangDuration);

		ShowLoadingScreen();

 		if ((Settings->LogLoadingScreenHeartbeatInterval > 0.0f) && (TimeUntilNextLogHeartbeatSeconds <= 0.0))
 		{
			bLogLoadingScreenStatus = true;
 			TimeUntilNextLogHeartbeatSeconds = Settings->LogLoadingScreenHeartbeatInterval;
 		}
	}
	else
	{
		HideLoadingScreen();
		/* å½“æ£€æŸ¥ç‚¹ç»“æŸæ—¶ï¼Œç”±çº¿ç¨‹è°ƒç”¨ */
 		FThreadHeartBeat::Get().MonitorCheckpointEnd(GetFName());
	}

	if (bLogLoadingScreenStatus)
	{
		UE_LOG(LogLoadingScreen, Log, TEXT("Loading screen showing: %d. Reason: %s"), bCurrentlyShowingLoadingScreen ? 1 : 0, *DebugReasonForShowingOrHidingLoadingScreen);
	}
}
```


#### å½“ä¸‹è®¡ç®—å¯è§†æ€§
``` cpp
bool ULoadingScreenManager::CheckForAnyNeedToShowLoadingScreen()
{
	// Start out with 'unknown' reason in case someone forgets to put a reason when changing this in the future.
	// ä¸€å¼€å§‹å°†åŸå› è®¾ä¸ºâ€œæœªçŸ¥â€ï¼Œä»¥é˜²æ—¥åæœ‰äººåœ¨ä¿®æ”¹æ­¤é¡¹å†…å®¹æ—¶å¿˜è®°å¡«å†™åŸå› ã€‚
	DebugReasonForShowingOrHidingLoadingScreen = TEXT("Reason for Showing/Hiding LoadingScreen is unknown!");

	const UGameInstance* LocalGameInstance = GetGameInstance();

	// æ˜¯å¦å¼ºåˆ¶æ˜¾ç¤º
	if (LoadingScreenCVars::ForceLoadingScreenVisible)
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("CommonLoadingScreen.AlwaysShow is true"));
		return true;
	}

	const FWorldContext* Context = LocalGameInstance->GetWorldContext();
	if (Context == nullptr)
	{
		// We don't have a world context right now... better show a loading screen
		// ç›®å‰æˆ‘ä»¬è¿˜æ²¡æœ‰å…¨çƒæ€§çš„èƒŒæ™¯ä¿¡æ¯â€¦â€¦æœ€å¥½æ˜¾ç¤ºä¸€ä¸ªåŠ è½½ç•Œé¢
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("The game instance has a null WorldContext"));
		return true;
	}

	UWorld* World = Context->World();
	// æ— ä¸–ç•Œ
	if (World == nullptr)
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("We have no world (FWorldContext's World() is null)"));
		return true;
	}

	AGameStateBase* GameState = World->GetGameState<AGameStateBase>();
	// æ— GameState
	if (GameState == nullptr)
	{
		// The game state has not yet replicated.
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("GameState hasn't yet replicated (it's null)"));
		return true;
	}

	// åŠ è½½åœ°å›¾ä¸­
	if (bCurrentlyInLoadMap)
	{
		// Show a loading screen if we are in LoadMap
		// å¦‚æœå¤„äºâ€œåŠ è½½åœ°å›¾â€çŠ¶æ€ï¼Œåˆ™æ˜¾ç¤ºåŠ è½½ç•Œé¢
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("bCurrentlyInLoadMap is true"));
		return true;
	}

	/** ç”¨äºå¤„ç†å¾…è¿æ¥å®¢æˆ·ç«¯çš„è·³è½¬ URL */
	if (!Context->TravelURL.IsEmpty())
	{
		// Show a loading screen when pending travel
		// å½“æœ‰å¾…å¤„ç†çš„è¡Œç¨‹æ—¶æ˜¾ç¤ºåŠ è½½ç•Œé¢
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("We have pending travel (the TravelURL is not empty)"));
		return true;
	}

	if (Context->PendingNetGame != nullptr)
	{
		// Connecting to another server
		// è¿æ¥åˆ°å¦ä¸€å°æœåŠ¡å™¨
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("We are connecting to another server (PendingNetGame != nullptr)"));
		return true;
	}

	// ä¸–ç•Œè¿˜æ²¡å¼€å§‹
	if (!World->HasBegunPlay())
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("World hasn't begun play"));
		return true;
	}

	if (World->IsInSeamlessTravel())
	{
		// Show a loading screen during seamless travel
		// åœ¨æ— ç¼åˆ‡æ¢è¿‡ç¨‹ä¸­æ˜¾ç¤ºåŠ è½½ç•Œé¢
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("We are in seamless travel"));
		return true;
	}

	// Ask the game state if it needs a loading screen
	// è°ƒç”¨æ¸¸æˆçŠ¶æ€å¯¹è±¡ï¼Œè¯¢é—®å…¶æ˜¯å¦éœ€è¦åŠ è½½ç•Œé¢
	if (ILoadingProcessInterface::ShouldShowLoadingScreen(GameState, /*out*/ DebugReasonForShowingOrHidingLoadingScreen))
	{
		return true;
	}

	// Ask any game state components if they need a loading screen
	// è¦æ±‚ä»»ä½•æ¸¸æˆçŠ¶æ€ç»„ä»¶å‘ŠçŸ¥è‡ªèº«æ˜¯å¦éœ€è¦åŠ è½½ç•Œé¢
	for (UActorComponent* TestComponent : GameState->GetComponents())
	{
		if (ILoadingProcessInterface::ShouldShowLoadingScreen(TestComponent, /*out*/ DebugReasonForShowingOrHidingLoadingScreen))
		{
			return true;
		}
	}

	// Ask any of the external loading processors that may have been registered.  These might be actors or components
	// that were registered by game code to tell us to keep the loading screen up while perhaps something finishes
	// streaming in.
	// è”ç³»ä»»ä½•å¯èƒ½å·²æ³¨å†Œçš„å¤–éƒ¨åŠ è½½å¤„ç†å™¨ã€‚è¿™äº›å¤„ç†å™¨å¯èƒ½æ˜¯ç”±æ¸¸æˆä»£ç æ³¨å†Œçš„æ¼”å‘˜æˆ–ç»„ä»¶ï¼Œå®ƒä»¬ä¼šå‘ŠçŸ¥æˆ‘ä»¬åº”ä¿æŒåŠ è½½ç•Œé¢å¤„äºæ˜¾ç¤ºçŠ¶æ€ï¼Œä»¥ä¾¿åœ¨æŸäº›å†…å®¹å®ŒæˆåŠ è½½ä¼ è¾“æ—¶èƒ½å¤Ÿæ˜¾ç¤ºå‡ºæ¥ã€‚
	for (const TWeakInterfacePtr<ILoadingProcessInterface>& Processor : ExternalLoadingProcessors)
	{
		if (ILoadingProcessInterface::ShouldShowLoadingScreen(Processor.GetObject(), /*out*/ DebugReasonForShowingOrHidingLoadingScreen))
		{
			return true;
		}
	}

	// Check each local player
	// æ£€æŸ¥æ¯ä¸ªæœ¬åœ°ç©å®¶
	bool bFoundAnyLocalPC = false;
	bool bMissingAnyLocalPC = false;

	for (ULocalPlayer* LP : LocalGameInstance->GetLocalPlayers())
	{
		if (LP != nullptr)
		{
			if (APlayerController* PC = LP->PlayerController)
			{
				bFoundAnyLocalPC = true;

				// Ask the PC itself if it needs a loading screen
				// è¦æ±‚ç”µè„‘è‡ªèº«ç¡®è®¤æ˜¯å¦éœ€è¦åŠ è½½ç”»é¢
				if (ILoadingProcessInterface::ShouldShowLoadingScreen(PC, /*out*/ DebugReasonForShowingOrHidingLoadingScreen))
				{
					return true;
				}

				// Ask any PC components if they need a loading screen
				// è¯¢é—®ä»»ä½•ç”µè„‘ç»„ä»¶æ˜¯å¦éœ€è¦åŠ è½½ç”»é¢
				for (UActorComponent* TestComponent : PC->GetComponents())
				{
					if (ILoadingProcessInterface::ShouldShowLoadingScreen(TestComponent, /*out*/ DebugReasonForShowingOrHidingLoadingScreen))
					{
						return true;
					}
				}
			}
			else
			{
				bMissingAnyLocalPC = true;
			}
		}
	}

	UGameViewportClient* GameViewportClient = LocalGameInstance->GetGameViewportClient();
	const bool bIsInSplitscreen = GameViewportClient->GetCurrentSplitscreenConfiguration() != ESplitScreenType::None;

	// In splitscreen we need all player controllers to be present
	// åœ¨åˆ†å±æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿æ‰€æœ‰ç©å®¶æ§åˆ¶å™¨éƒ½å¤„äºå¼€å¯çŠ¶æ€
	if (bIsInSplitscreen && bMissingAnyLocalPC)
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("At least one missing local player controller in splitscreen"));
		return true;
	}

	// And in non-splitscreen we need at least one player controller to be present
	// åœ¨éåˆ†å±æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦æœ‰ä¸€ä¸ªç©å®¶æ§åˆ¶å™¨åœ¨åœºã€‚
	if (!bIsInSplitscreen && !bFoundAnyLocalPC)
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("Need at least one local player controller"));
		return true;
	}

	// Victory! The loading screen can go away now
	// èƒœåˆ©ï¼åŠ è½½ç”»é¢ç°åœ¨å¯ä»¥æ¶ˆå¤±äº†
	DebugReasonForShowingOrHidingLoadingScreen = TEXT("(nothing wants to show it anymore)");
	return false;
}
```


#### å»¶æ—¶è¡¥å……å¯è§†æ€§
``` cpp
	const UCommonLoadingScreenSettings* Settings = GetDefault<UCommonLoadingScreenSettings>();

	// Check debugging commands that force the state one way or another
	// æ£€æŸ¥é‚£äº›èƒ½å¤Ÿå¼ºåˆ¶æ”¹å˜çŠ¶æ€çš„è°ƒè¯•å‘½ä»¤
#if !UE_BUILD_SHIPPING
	// å‘½ä»¤è¡Œæ— åŠ è½½ç•Œé¢
	static bool bCmdLineNoLoadingScreen = FParse::Param(FCommandLine::Get(), TEXT("NoLoadingScreen"));
	if (bCmdLineNoLoadingScreen)
	{
		DebugReasonForShowingOrHidingLoadingScreen = FString(TEXT("CommandLine has 'NoLoadingScreen'"));
		return false;
	}
#endif

	// Can't show a loading screen if there's no game viewport
	// è‹¥æ²¡æœ‰æ¸¸æˆè§†å›¾åŒºåŸŸï¼Œåˆ™æ— æ³•æ˜¾ç¤ºåŠ è½½å±å¹•
	UGameInstance* LocalGameInstance = GetGameInstance();
	if (LocalGameInstance->GetGameViewportClient() == nullptr)
	{
		return false;
	}

	// Check for a need to show the loading screen
	// æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºåŠ è½½ç•Œé¢
	const bool bNeedToShowLoadingScreen = CheckForAnyNeedToShowLoadingScreen();

	// Keep the loading screen up a bit longer if desired
	// å¦‚æœéœ€è¦çš„è¯ï¼Œå¯ä»¥è®©åŠ è½½ç•Œé¢å¤šæ˜¾ç¤ºä¸€æ®µæ—¶é—´
	bool bWantToForceShowLoadingScreen = false;
	if (bNeedToShowLoadingScreen)
	{
		// Still need to show it
		// ä»éœ€å±•ç¤ºå®ƒ
		TimeLoadingScreenLastDismissed = -1.0;
	}
	else
	{
		// Don't *need* to show the screen anymore, but might still want to for a bit
		// æ— éœ€å†æ˜¾ç¤ºè¯¥å±å¹•äº†ï¼Œä½†å¯èƒ½ä»éœ€è¦å±•ç¤ºä¸€å°æ®µæ—¶é—´ã€‚
		const double CurrentTime = FPlatformTime::Seconds();
		const bool bCanHoldLoadingScreen = (!GIsEditor || Settings->HoldLoadingScreenAdditionalSecsEvenInEditor);
		const double HoldLoadingScreenAdditionalSecs = bCanHoldLoadingScreen ? LoadingScreenCVars::HoldLoadingScreenAdditionalSecs : 0.0;

		if (TimeLoadingScreenLastDismissed < 0.0)
		{
			TimeLoadingScreenLastDismissed = CurrentTime;
		}
		const double TimeSinceScreenDismissed = CurrentTime - TimeLoadingScreenLastDismissed;

		// hold for an extra X seconds, to cover up streaming
		// å»¶é•¿ç­‰å¾… X ç§’ï¼Œä»¥å¼¥è¡¥æ•°æ®ä¼ è¾“çš„å»¶è¿Ÿ
		if ((HoldLoadingScreenAdditionalSecs > 0.0) && (TimeSinceScreenDismissed < HoldLoadingScreenAdditionalSecs))
		{
			// Make sure we're rendering the world at this point, so that textures will actually stream in
			//@TODO: If bNeedToShowLoadingScreen bounces back true during this window, we won't turn this off again...
			
			// ç¡®ä¿æ­¤æ—¶æˆ‘ä»¬æ­£åœ¨æ¸²æŸ“æ•´ä¸ªä¸–ç•Œï¼Œè¿™æ ·çº¹ç†æ‰èƒ½çœŸæ­£åŠ è½½è¿›æ¥
			//@å¾…åŠäº‹é¡¹ï¼šå¦‚æœåœ¨è¿™ä¸€çª—å£æœŸé—´ bNeedToShowLoadingScreen çš„å€¼åå‘å˜ä¸º trueï¼Œæˆ‘ä»¬å°±ä¸ä¼šå†æ¬¡å°†å…¶å…³é—­â€¦â€¦
			
			UGameViewportClient* GameViewportClient = GetGameInstance()->GetGameViewportClient();
			/** æ˜¯å¦è®¾ç½®ä¸ºç¦ç”¨ä¸–ç•Œæ¸²æŸ“ */
			// å¼€å§‹æ¸²æŸ“3Dç”»é¢
			GameViewportClient->bDisableWorldRendering = false;

			DebugReasonForShowingOrHidingLoadingScreen = FString::Printf(TEXT("Keeping loading screen up for an additional %.2f seconds to allow texture streaming"), HoldLoadingScreenAdditionalSecs);
			bWantToForceShowLoadingScreen = true;
		}
	}

	return bNeedToShowLoadingScreen || bWantToForceShowLoadingScreen;
```


### è°ƒç”¨æ‰§è¡Œ
``` cpp
void ULoadingScreenManager::Initialize(FSubsystemCollectionBase& Collection)
{
	/** åœ¨åŠ è½½åœ°å›¾æ“ä½œä¹‹åˆå‘é€ */
	FCoreUObjectDelegates::PreLoadMapWithContext.AddUObject(this, &ThisClass::HandlePreLoadMap);

	/** åœ¨åŠ è½½åœ°å›¾æ“ä½œå®Œæˆåå‘é€ */
	FCoreUObjectDelegates::PostLoadMapWithWorld.AddUObject(this, &ThisClass::HandlePostLoadMap);

	const UGameInstance* LocalGameInstance = GetGameInstance();
	check(LocalGameInstance);
}


void ULoadingScreenManager::HandlePreLoadMap(const FWorldContext& WorldContext, const FString& MapName)
{
	if (WorldContext.OwningGameInstance == GetGameInstance())
	{
		bCurrentlyInLoadMap = true;

		// Update the loading screen immediately if the engine is initialized
		// è‹¥å¼•æ“å·²åˆå§‹åŒ–ï¼Œåˆ™ç«‹å³æ›´æ–°åŠ è½½ç•Œé¢
		if (GEngine->IsInitialized())
		{
			UpdateLoadingScreen();
		}
	}
}
```
``` cpp
void ULoadingScreenManager::Tick(float DeltaTime)
{
	UpdateLoadingScreen();

	TimeUntilNextLogHeartbeatSeconds = FMath::Max(TimeUntilNextLogHeartbeatSeconds - DeltaTime, 0.0);
}
```


### å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸ
æ³¨æ„æ­¤å¤„åªæ˜¯ç”¨äºæ‰‹åŠ¨çš„.å®é™…ä¸Šä¼šè‡ªåŠ¨è®¿é—®GameStateåŠå…¶ç»„ä»¶æ˜¯å¦éœ€è¦è¿™ä¸ªåŠŸèƒ½!
``` cpp
	// ç”±å…·ä½“çš„æ¥å£å®ä¾‹è¿›è¡Œç”Ÿå‘½å‘¨æœŸçš„æ³¨å†Œ
	UE_API void RegisterLoadingProcessor(TScriptInterface<ILoadingProcessInterface> Interface);
	UE_API void UnregisterLoadingProcessor(TScriptInterface<ILoadingProcessInterface> Interface);
```
``` cpp
/*static*/ ULoadingProcessTask* ULoadingProcessTask::CreateLoadingScreenProcessTask(UObject* WorldContextObject, const FString& ShowLoadingScreenReason)
{
	UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);
	UGameInstance* GameInstance = World ? World->GetGameInstance() : nullptr;
	ULoadingScreenManager* LoadingScreenManager = GameInstance ? GameInstance->GetSubsystem<ULoadingScreenManager>() : nullptr;

	if (LoadingScreenManager)
	{
		ULoadingProcessTask* NewLoadingTask = NewObject<ULoadingProcessTask>(LoadingScreenManager);
		NewLoadingTask->SetShowLoadingScreenReason(ShowLoadingScreenReason);

		LoadingScreenManager->RegisterLoadingProcessor(NewLoadingTask);
		
		return NewLoadingTask;
	}

	return nullptr;
}
```


### å¤–éƒ¨é—»è®¯
#### ä»£ç†
``` cpp
private:
	/** Delegate broadcast when the loading screen visibility changes */
	/** å½“åŠ è½½ç•Œé¢çš„å¯è§æ€§å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰§è¡Œå¹¿æ’­æ“ä½œ */
	FOnLoadingScreenVisibilityChangedDelegate LoadingScreenVisibilityChanged;
```
#### è®¿é—®
``` cpp
	// æš´éœ²ç»™è“å›¾è¯¢é—®
	UFUNCTION(BlueprintCallable, Category=LoadingScreen)
	FString GetDebugReasonForShowingOrHidingLoadingScreen() const
	{
		return DebugReasonForShowingOrHidingLoadingScreen;
	}
```


## CommonLoadingScreenSettings(é€šç”¨ç•Œé¢åŠ è½½è®¾ç½®)
**å…·ä½“ä½¿ç”¨æ˜¯åœ¨ç¼–è¾‘å™¨ä¸­ProjectSettings->Gane->Common Loading Screenè¿›è¡Œé…ç½®ä½¿ç”¨**
```cpp
/**
 * Settings for a loading screen system.
 * åŠ è½½å±å¹•ç³»ç»Ÿçš„è®¾ç½®ã€‚
 */
UCLASS(config=Game, defaultconfig, meta=(DisplayName="Common Loading Screen"))
class UCommonLoadingScreenSettings : public UDeveloperSettingsBackedByCVars
{
	GENERATED_BODY()

public:
	UCommonLoadingScreenSettings();

public:
	
	// The widget to load for the loading screen.
	// ç”¨äºåŠ è½½å±å¹•çš„åŠ è½½ç»„ä»¶ã€‚
	UPROPERTY(config, EditAnywhere, Category=Display, meta=(MetaClass="/Script/UMG.UserWidget"))
	FSoftClassPath LoadingScreenWidget;

	// The z-order of the loading screen widget in the viewport stack
	// è§†å›¾å †æ ˆä¸­åŠ è½½å±å¹•ç»„ä»¶çš„å±‚çº§é¡ºåº
	UPROPERTY(config, EditAnywhere, Category=Display)
	int32 LoadingScreenZOrder = 10000;

	// How long to hold the loading screen up after other loading finishes (in seconds) to
	// try to give texture streaming a chance to avoid blurriness
	//
	// Note: This is not normally applied in the editor for iteration time, but can be 
	// enabled via HoldLoadingScreenAdditionalSecsEvenInEditor
	// å…¶ä»–åŠ è½½å®Œæˆä¹‹åï¼Œè¦å°†åŠ è½½ç•Œé¢ä¿æŒæ˜¾ç¤ºå¤šé•¿æ—¶é—´ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ï¼Œä»¥æœŸè®©çº¹ç†æµåŠ è½½æœ‰æœºä¼šé¿å…å‡ºç°æ¨¡ç³Šç°è±¡//
	// æ³¨æ„ï¼šé€šå¸¸æƒ…å†µä¸‹ï¼Œæ­¤åŠŸèƒ½ä¸é€‚ç”¨äºç¼–è¾‘å™¨ä¸­çš„è¿­ä»£æ—¶é—´ï¼Œä½†å¯ä»¥é€šè¿‡â€œHoldLoadingScreenAdditionalSecsEvenInEditorâ€é€‰é¡¹æ¥å¯ç”¨ã€‚
 	UPROPERTY(config, EditAnywhere, Category=Configuration, meta=(ForceUnits=s, ConsoleVariable="CommonLoadingScreen.HoldLoadingScreenAdditionalSecs"))
	float HoldLoadingScreenAdditionalSecs = 2.0f;

	// The interval in seconds beyond which the loading screen is considered permanently hung (if non-zero).
	// è¶…è¿‡æ­¤æ—¶é—´é—´éš”ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰åï¼ŒåŠ è½½ç•Œé¢å°†è¢«è§†ä¸ºæ°¸ä¹…æ€§å¡ä½ï¼ˆè‹¥è¯¥å€¼éé›¶ï¼‰ã€‚
 	UPROPERTY(config, EditAnywhere, Category=Configuration, meta=(ForceUnits=s))
	float LoadingScreenHeartbeatHangDuration = 0.0f;

	// The interval in seconds between each log of what is keeping a loading screen up (if non-zero).
	// æ¯æ¬¡è®°å½•åŠ è½½å±å¹•ä¿æŒçŠ¶æ€å˜åŒ–çš„æ—¶é—´é—´éš”ï¼ˆè‹¥ä¸ä¸ºé›¶ï¼‰ã€‚å•ä½ï¼šç§’ã€‚
 	UPROPERTY(config, EditAnywhere, Category=Configuration, meta=(ForceUnits=s))
	float LogLoadingScreenHeartbeatInterval = 5.0f;

	// When true, the reason the loading screen is shown or hidden will be printed to the log every frame.
	// è‹¥ä¸ºçœŸï¼Œåˆ™æ¯æ¬¡æ¸²æŸ“æ—¶éƒ½ä¼šå°†åŠ è½½ç•Œé¢æ˜¾ç¤ºæˆ–éšè—çš„åŸå› è®°å½•åˆ°æ—¥å¿—ä¸­ã€‚
	UPROPERTY(Transient, EditAnywhere, Category=Debugging, meta=(ConsoleVariable="CommonLoadingScreen.LogLoadingScreenReasonEveryFrame"))
	bool LogLoadingScreenReasonEveryFrame = 0;

	// Force the loading screen to be displayed (useful for debugging)
	// å¼ºåˆ¶æ˜¾ç¤ºåŠ è½½ç•Œé¢ï¼ˆç”¨äºè°ƒè¯•ä¹‹ç”¨ï¼‰
	UPROPERTY(Transient, EditAnywhere, Category=Debugging, meta=(ConsoleVariable="CommonLoadingScreen.AlwaysShow"))
	bool ForceLoadingScreenVisible = false;

	// Should we apply the additional HoldLoadingScreenAdditionalSecs delay even in the editor
	// (useful when iterating on loading screens)
	// æˆ‘ä»¬æ˜¯å¦åº”è¯¥åœ¨ç¼–è¾‘å™¨ä¸­ä¹Ÿä½¿ç”¨é¢å¤–çš„â€œä¿æŒåŠ è½½ç•Œé¢æ˜¾ç¤ºæ—¶é—´ï¼ˆé¢å¤–ç§’æ•°ï¼‰â€è¿™ä¸€è®¾ç½®å‘¢ï¼Ÿ
	// ï¼ˆåœ¨å¯¹åŠ è½½ç•Œé¢è¿›è¡Œæ”¹è¿›æ—¶ï¼Œæ­¤è®¾ç½®å¾ˆæœ‰ç”¨ï¼‰
	UPROPERTY(Transient, EditAnywhere, Category=Debugging)
	bool HoldLoadingScreenAdditionalSecsEvenInEditor = false;

	// Should we apply the additional HoldLoadingScreenAdditionalSecs delay even in the editor
	// (useful when iterating on loading screens)
	// æˆ‘ä»¬æ˜¯å¦åº”è¯¥åœ¨ç¼–è¾‘å™¨ä¸­ä¹Ÿä½¿ç”¨é¢å¤–çš„â€œä¿æŒåŠ è½½ç•Œé¢æ˜¾ç¤ºæ—¶é—´ï¼ˆé¢å¤–ç§’æ•°ï¼‰â€è¿™ä¸€è®¾ç½®å‘¢ï¼Ÿ
	// ï¼ˆåœ¨å¯¹åŠ è½½ç•Œé¢è¿›è¡Œæ”¹è¿›æ—¶ï¼Œæ­¤è®¾ç½®å¾ˆæœ‰ç”¨ï¼‰
	UPROPERTY(config, EditAnywhere, Category=Configuration)
	bool ForceTickLoadingScreenEvenInEditor = true;
};
```


## LoadingProcessTask(åŠ è½½è¿›ç¨‹ä»»åŠ¡)
```cpp
// åˆ›å»ºä¸€ä¸ªæ¥å£å®ä¾‹,ç”¨æ¥ä¸´æ—¶æ˜¾ç¤ºåŠ è½½å±å¹•.
// æ³¨æ„ä¸€å®šè¦æŒæœ‰è¿™ä¸ªå¯¹è±¡,é˜²æ­¢GC
// å’Œå¼‚æ­¥è“å›¾èŠ‚ç‚¹çš„å†™æ³•å¾ˆåƒ.
UCLASS(MinimalAPI, BlueprintType)
class ULoadingProcessTask : public UObject, public ILoadingProcessInterface
{
	GENERATED_BODY()
	
public:
	UFUNCTION(BlueprintCallable, meta=(WorldContext = "WorldContextObject"))
	static UE_API ULoadingProcessTask* CreateLoadingScreenProcessTask(UObject* WorldContextObject, const FString& ShowLoadingScreenReason);

public:
	ULoadingProcessTask() { }

	UFUNCTION(BlueprintCallable)
	UE_API void Unregister();

	UFUNCTION(BlueprintCallable)
	UE_API void SetShowLoadingScreenReason(const FString& InReason);

	UE_API virtual bool ShouldShowLoadingScreen(FString& OutReason) const override;
	
	FString Reason;
};
```
### è“å›¾è°ƒç”¨
æ­¤å¤„ä¸º**B_LoadRandomLobbyBackground**ç±»çš„è“å›¾
![BP_LoadingProcessTask](./assets/img/Pictures/BP_LoadingProcessTask.png)

![CommonLoadingScreenSettings_Level](./assets/img/Pictures/CommonLoadingScreenSettings_Level.png)


### ä»£ç å®ç°
ç”¨æ¥åœ¨å‰ç«¯ç•Œé¢æµé€èƒŒæ™¯å…³å¡çš„èµ„äº§å®šä¹‰
``` cpp
/**
 * Developer settings / editor cheats
 * å¼€å‘è€…è®¾ç½® / ç¼–è¾‘å™¨ä½œå¼ŠåŠŸèƒ½
 *
 * ç”¨æ¥åŠ è½½èƒŒæ™¯çš„èµ„äº§,è¿™ä¸ªèµ„äº§éœ€è¦è¿›è¡Œæ‰«æ
 */
UCLASS(config=EditorPerProjectUserSettings, MinimalAPI)
class ULyraLobbyBackground : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSoftObjectPtr<UWorld> BackgroundLevel;
};
```
``` cpp
/*static*/ ULoadingProcessTask* ULoadingProcessTask::CreateLoadingScreenProcessTask(UObject* WorldContextObject, const FString& ShowLoadingScreenReason)
{
	UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);
	UGameInstance* GameInstance = World ? World->GetGameInstance() : nullptr;
	ULoadingScreenManager* LoadingScreenManager = GameInstance ? GameInstance->GetSubsystem<ULoadingScreenManager>() : nullptr;

	if (LoadingScreenManager)
	{
		ULoadingProcessTask* NewLoadingTask = NewObject<ULoadingProcessTask>(LoadingScreenManager);
		NewLoadingTask->SetShowLoadingScreenReason(ShowLoadingScreenReason);

		LoadingScreenManager->RegisterLoadingProcessor(NewLoadingTask);
		
		return NewLoadingTask;
	}

	return nullptr;
}

void ULoadingProcessTask::Unregister()
{
	ULoadingScreenManager* LoadingScreenManager = Cast<ULoadingScreenManager>(GetOuter());
	LoadingScreenManager->UnregisterLoadingProcessor(this);
}

void ULoadingProcessTask::SetShowLoadingScreenReason(const FString& InReason)
{
	Reason = InReason;
}

bool ULoadingProcessTask::ShouldShowLoadingScreen(FString& OutReason) const
{
	OutReason = Reason;
	return true;
}
```
**è®°å¾—é…ç½®æ£€ç´¢è·¯å¾„!**
**LyraLobbyBackground**åœ¨**ShooterMaps.GameFeatureData**ä¸­!
ä¸é…ç½®è¯çš„å°±æ‰¾ä¸åˆ°è¿™ä¸ªèµ„äº§!!!!
```ini
[/Script/Engine.AssetManagerSettings]
(PrimaryAssetType="LyraLobbyBackground",AssetBaseClass="/Script/LyraGame.LyraLobbyBackground",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="Items/Backgrounds")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
```
![LyraLobbyBackground](./assets/img/Pictures/LyraLobbyBackground.png)


## CommonStartupLoadingScreen(é€šç”¨å¯åŠ¨åŠ è½½ç•Œé¢)
ä¸»è¦å®ç°æ•ˆæœ
![CommonPreLoadingScreenWidget](./assets/img/Pictures/CommonPreLoadingScreenWidget.png)
### SCommonPreLoadingScreenWidget
å¤´æ–‡ä»¶(.h)
```cpp
class FReferenceCollector;

class SCommonPreLoadingScreenWidget : public SCompoundWidget, public FGCObject
{
public:
	SLATE_BEGIN_ARGS(SCommonPreLoadingScreenWidget) {}
    SLATE_END_ARGS()

    void Construct(const FArguments& InArgs);

	//~ Begin FGCObject interface
	virtual void AddReferencedObjects(FReferenceCollector& Collector) override;
	virtual FString GetReferencerName() const override;
	//~ End FGCObject interface
private:
};
```
æºæ–‡ä»¶(.cpp)
```cpp
void SCommonPreLoadingScreenWidget::Construct(const FArguments& InArgs)
{
	// Create the widget content
	// åˆ›å»ºæ§ä»¶å†…å®¹
	ChildSlot
		[
			SNew(SBorder)	// Create a new border widget
				// åˆ›å»ºä¸€ä¸ªæ–°çš„è¾¹æ¡†æ§ä»¶
				.BorderImage(FCoreStyle::Get().GetBrush("WhiteBrush"))	// Set border image to white brush
				// è®¾ç½®è¾¹æ¡†å›¾åƒä¸ºç™½è‰²ç”»åˆ·
				.BorderBackgroundColor(FLinearColor::Black)				// Set background color to black
				// è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸ºé»‘è‰²
				.Padding(0)												// Set padding to zero
				// è®¾ç½®å†…è¾¹è·ä¸ºé›¶
		];
}

void SCommonPreLoadingScreenWidget::AddReferencedObjects(FReferenceCollector& Collector)
{
	//WidgetAssets.AddReferencedObjects(Collector);
}

FString SCommonPreLoadingScreenWidget::GetReferencerName() const
{
	return TEXT("SCommonPreLoadingScreenWidget");
}
```


#### Slateç•Œé¢å®ä¾‹åŒ–ä½ç½®
å¤´æ–‡ä»¶(.h)
```cpp
//åŸºç±»
//ç”¨äºå¤„ç†é¢„åŠ è½½å±å¹•ç›¸å…³é€»è¾‘çš„åŸºç±»å®ç°ï¼Œè´Ÿè´£æ§åˆ¶/æ›´æ–°é¢„åŠ è½½å±å¹•çš„ç”¨æˆ·ç•Œé¢
//è®¾è®¡ä¸ºå¯è¢«ç‰¹å®šæ¸¸æˆæ’ä»¶é‡å†™ï¼Œè¯¥æ’ä»¶ä¼šè°ƒç”¨FPreloadScreeManage::RegisterPreLoadScreenæ–¹æ³•ï¼Œä»¥ä¾¿é¢„åŠ è½½å±å¹•ç®¡ç†å™¨èƒ½å¤Ÿæ­£ç¡®è°ƒç”¨ç›¸å…³å‡½æ•°

class FCommonPreLoadScreen : public FPreLoadScreenBase
{
public:
	
    /*** IPreLoadScreen Implementation ***/
	virtual void Init() override;
    virtual EPreLoadScreenTypes GetPreLoadScreenType() const override { return EPreLoadScreenTypes::EngineLoadingScreen; }
    virtual TSharedPtr<SWidget> GetWidget() override { return EngineLoadingWidget; }
private:

    TSharedPtr<SWidget> EngineLoadingWidget;
};
```
æºæ–‡ä»¶(.cpp)
```cpp
void FCommonPreLoadScreen::Init()
{
	if (!GIsEditor && FApp::CanEverRender())
	{
		EngineLoadingWidget = SNew(SCommonPreLoadingScreenWidget);
	}
}
```


### å…·ä½“å®ç°æµç¨‹
```cpp
void FCommonPreLoadScreen::Init()
{
	if (!GIsEditor && FApp::CanEverRender())
	{
		EngineLoadingWidget = SNew(SCommonPreLoadingScreenWidget);
	}
}	
```


# é¡¹ç›®æŠ¥é”™æƒ…å†µ
## é¡¹ç›®Experienceèµ„äº§æœªæ­£å¸¸é…ç½®
è¯·ç¡®ä¿èµ„äº§ç®¡ç†å™¨ä¸­å¯¹äºExperienceçš„æ£€ç´¢å®šä¹‰å·²ç¡®è®¤.å¦åˆ™ä¼šå‡ºç°å¦‚ä¸‹å´©æºƒ:

| æ—¥å¿—è¯¦ç»†çº§åˆ« | æ‰“å°åœ¨æ§åˆ¶å°ä¸­ | æ‰“å°åœ¨ç¼–è¾‘å™¨æ—¥å¿—ä¸­ | æ–‡æœ¬é¢œè‰² | å…¶ä»–ä¿¡æ¯ |
|-------------|----------------|-------------------|----------|----------|
| æ—¥å¿—ï¼ˆLogï¼‰ | âŒ å¦ | âœ… æ˜¯ | âš« ç°è‰² | âŒ ä¸é€‚ç”¨ |
| é”™è¯¯ï¼ˆErrorï¼‰ | âœ… æ˜¯ | âœ… æ˜¯ | ğŸ”´ çº¢è‰² | ä½“éªŒèµ„æºåŠ è½½å¤±è´¥ï¼ŒAsset ID è§£æé”™è¯¯ |
| æ—¥å¿—ï¼ˆLogï¼‰ | âŒ å¦ | âœ… æ˜¯ | âš« ç°è‰² | âŒ ä¸é€‚ç”¨ |
| è­¦å‘Šï¼ˆWarningï¼‰ | âœ… æ˜¯ | âœ… æ˜¯ | ğŸŸ¡ é»„è‰² | è„šæœ¬å †æ ˆä¸ºç©º |
| é”™è¯¯ï¼ˆErrorï¼‰ | âœ… æ˜¯ | âœ… æ˜¯ | ğŸ”´ çº¢è‰² | æ–­è¨€å¤±è´¥ï¼šAssetClassï¼Œæ–‡ä»¶ LyraExperienceManagerComponent.cpp:91 |
| æ—¥å¿—ï¼ˆLogï¼‰ | âŒ å¦ | âœ… æ˜¯ | âš« ç°è‰² | Windows ç³»ç»Ÿé”™è¯¯ï¼šæ“ä½œæˆåŠŸå®Œæˆ (0) |


## æœªä¿®æ”¹é…ç½®å¯¼è‡´å´©æºƒ
DefaultGame.ini
```ini
[/Script/LyraGame.LyraUIManagerSubsystem]
; é»˜è®¤çš„UIç®¡ç†ç­–ç•¥
DefaultUIPolicyClass=/Game/UI/B_LyraUIPolicy.B_LyraUIPolicy_C
```

**å¦‚æœæ²¡æœ‰é…ç½®çš„è¯,ä¼šåœ¨è¿™é‡Œå´©æºƒ!å› ä¸ºç©ºæŒ‡é’ˆäº†!**
``` cpp
void UGameUIManagerSubsystem::NotifyPlayerAdded(UCommonLocalPlayer* LocalPlayer)
{
	if (ensure(LocalPlayer) && CurrentPolicy)
	{
		CurrentPolicy->NotifyPlayerAdded(LocalPlayer);
	}
}
```


## æœªæ˜¾ç¤ºåŠ è½½ç•Œé¢
DefaultGame.ini
```ini
[/Script/CommonLoadingScreen.CommonLoadingScreenSettings]
; é»˜è®¤çš„åŠ è½½ç•Œé¢
LoadingScreenWidget=/Game/UI/Foundation/LoadingScreen/W_LoadingScreen_Host.W_LoadingScreen_Host_C
; å¼ºåˆ¶TickåŠ è½½ç•Œé¢å³ä½¿æ˜¯åœ¨ç¼–è¾‘å™¨
ForceTickLoadingScreenEvenInEditor=False
```
![CommonLoadingScreenSettings](./assets/img/Pictures/CommonLoadingScreenSettings_ProjectSettings.png)
å¦‚æœæ²¡é…ç½® è“å›¾è¿è¡Œä¼šæç¤ºæ—¥å¿—æŠ¥é”™
``` ini
PIE: Error: CreateWidget called with a null class.
LogLoadingScreen: Error: Failed to load the loading screen widget , falling back to placeholder.
```
**éœ€åœ¨GameModeä¸­ä½¿ç”¨CommonPlayerControllerç±»**